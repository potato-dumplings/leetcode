package jul;

import java.util.*;

/**
 * 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。
 *
 * 再给你一个整数数组 queries 。第 j 个查询的答案是满足lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。
 *
 * 以数组形式返回对应查询的所有答案。
 *
 * 
 *
 * 示例 1：
 *
 * 输入：intervals = [[1,4},{2,4},{3,6},{4,4]], queries = [2,3,4,5]
 * 输出：[3,3,1,4]
 * 解释：查询处理如下：
 * - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
 * - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
 * - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
 * - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。
 * 示例 2：
 *
 * 输入：intervals = [[2,3},{2,5},{1,8},{20,25]], queries = [2,19,5,22]
 * 输出：[2,-1,4,6]
 * 解释：查询处理如下：
 * - Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
 * - Query = 19：不存在包含 19 的区间，答案为 -1 。
 * - Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
 * - Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。
 * 
 *
 * 提示：
 *
 * 1 <= intervals.length <= 10^5
 * 1 <= queries.length <= 10^5
 * queries[i].length == 2
 * 1 <= lefti <= righti <= 10^7
 * 1 <= queries[j] <= 10^7
 *
 */
public class Jul1851 {

    public static int[] minInterval(int[][] intervals, int[] queries) {
        //先按左端点从小到大排序
        Arrays.sort(intervals, Comparator.comparingInt( o -> o[0] ) );
        //因为我们之后要排序queries数组，但是答案又要按顺序输出，所以我们这里用一个二维数组来保存要查询的值和其下标
        int[][] que = new int[queries.length][2];
        for(int i = 0; i < queries.length; i++){
            que[i][0] = queries[i];
            que[i][1] = i;
        }
        //按查询数组升序排列
        Arrays.sort(que, Comparator.comparingInt( v -> v[0] ) );
        int[] ans = new int[queries.length];
        //默认ans数组所有值都不存在最小区间，如果之后找到了最小区间会覆盖
        Arrays.fill(ans, -1);
        //创建优先队列,按照区间长度升序排列
        PriorityQueue<int[]> queue = new PriorityQueue<>( Comparator.comparingInt( o -> (o[1] - o[0]) ) );
        //遍历intervals左区间的位置
        int index = 0;
        for(int i = 0; i < queries.length; i++){
            // 避免重复判断，如果前面已经判断过相同的数，直接采纳前面的
            if (i != 0 && que[i - 1][0] == que[i][0]) {
                ans[que[i][1]] = ans[que[i - 1][1]];
                continue;
            }

            //将所有起始位置小于等于查询位置的区间intervals[i]添加到优先队列中
            while(index < intervals.length && que[i][0] >= intervals[index][0]){
                queue.offer(new int[]{intervals[index][0], intervals[index][1]});
                index++;
            }
            //将队列中不能覆盖要查询点的区间移除队列
            while(!queue.isEmpty() && queue.peek()[1] < que[i][0]) {
                queue.poll();
            }
            //如果队列不为空，则代表队首区间是要查询的点的最短区间
            if(!queue.isEmpty()){
                int[] t = queue.peek();
                ans[que[i][1]] = t[1] - t[0] + 1;   //que[i][1]代表这个查询原来的下标
            }
        }
        return ans;

////        // 排序intervals
////        Arrays.sort(intervals, Comparator.comparingInt( o -> o[0] ) );
////
////        // 排序queries，同时记录下标
////        int[][] newQueries = new int[queries.length][2];
////        for (int i = 0; i < queries.length; i++) {
////            newQueries[i][0] = queries[i];
////            newQueries[i][1] = i;
////        }
////        Arrays.sort(newQueries, Comparator.comparingInt( v -> v[0] ) );
////
////        // 记录答案
////        PriorityQueue<int[]> queue = new PriorityQueue<>( Comparator.comparingInt( a -> a[0] ) );
////        int[] res = new int[queries.length];
////        Arrays.fill(res, -1);
////
////        int index = 0;
////        for (int i = 0; i < newQueries.length; i++) {
////            int qi = newQueries[i][0];
////            //将所有起始位置小于等于查询位置的区间intervals[i]添加到优先队列中
////            while(index < intervals.length && newQueries[i][0] >= intervals[index][0]){
////                queue.offer(new int[]{intervals[index][0], intervals[index][1]});
////                index++;
////            }
////            //将队列中不能覆盖要查询点的区间移除队列
////            while (!queue.isEmpty() && queue.peek()[1] < newQueries[i][0]) {
////                queue.poll();
////            }
////            //如果队列不为空，则代表队首区间是要查询的点的最短区间
////            if(!queue.isEmpty()){
////                int[] t = queue.peek();
////                //que[i][1]代表这个查询原来的下标
////                res[newQueries[i][1]] = t[1] - t[0] + 1;
////            }
////        }
//
//        return res;
    }

    public static void main(String[] args) {
        minInterval( new int[][]{{2,3},{2,5},{1,8},{20,25}}, new int[]{2,19,5,22} );
        minInterval( new int[][]{{6,6},{5,5},{10,10},{3,6},{9,9},{7,7},{2,10},{5,5},{3,7},{10,10}},
                new int[]{1,8,9,1,8,3,9,3,10,1}
        );
        minInterval( new int[][]{{54,82},{55,66},{81,89},{38,67},{81,86},{47,47},{13,61},{33,39},{61,66},{97,97},{52,68},{96,98},{89,92},{1,41},{81,89},{9,57},{81,90},{41,73},{29,80},{98,98},{61,95},{93,98},{5,65},{91,96},{91,99},{28,68},{55,71},{35,45},{1,89},{48,48},{26,36},{5,83},{20,83},{73,92},{69,69},{77,89},{12,52},{5,53},{33,53},{70,83},{81,98},{69,69},{28,90},{9,77},{40,53},{53,71},{7,55},{7,28},{5,88},{61,68},{25,93},{45,73},{13,51},{27,70},{47,87},{71,91},{93,98},{1,35},{24,39},{86,90},{19,33},{1,69},{21,100},{85,85},{99,99},{25,25},{90,94},{13,61},{69,85},{89,97},{1,43},{11,35},{41,95},{31,99},{86,94},{33,63},{22,91},{61,75},{71,83},{31,85},{28,83},{1,21},{81,97},{5,29},{74,83},{33,83},{13,24},{92,94},{71,71},{59,79},{21,37},{33,87},{97,97},{34,57},{11,59},{57,62},{22,23},{13,53},{84,85},{71,80}},
                new int[]{31,9,21,91,91,58,13,76,21,69,41,1,73,2,71,51,69,89,31,85,61,61,39,76,36,50,1,33,41,38,29,91,93,47,1,11,33,79,15,7,21,36,65,1,1,93,45,51,33,5,15,65,49,81,59,21,1,7,81,6,1,80,81,21,24,41,47,85,38,26,100,33,57,24,71,16,65,96,81,83,17,75,76,21,85,47,77,49,31,61,9,49,1,73,32,66,96,97,30,21}
        );
        minInterval( new int[][]{{41,86},{57,81},{24,28},{5,69},{21,98},{4,95},{41,76},{61,99},{52,72},{51,67},{47,67},{81,91},{93,94},{72,72},{70,89},{68,77},{41,41},{41,77},{68,77},{65,73},{11,65},{40,94},{87,94},{95,97},{19,85},{11,26},{65,85},{77,86},{25,49},{46,77},{51,67},{29,83},{5,93},{83,99},{38,50},{73,80},{41,41},{92,100},{39,59},{81,100},{1,85},{39,78},{99,100},{12,93},{71,74},{57,63},{86,99},{28,65},{62,68},{53,77},{29,53},{97,97},{41,61},{1,88},{67,87},{85,95},{1,13},{67,73},{38,42},{1,11},{45,61},{71,73},{55,99},{75,87},{46,98},{45,93},{61,71},{31,74},{95,98},{84,90},{69,95},{67,68},{41,68},{87,94},{40,73},{93,93},{73,95},{61,73},{64,78},{4,20},{81,96},{40,48},{4,11},{40,56},{33,74},{23,80},{53,74},{30,87},{65,69},{51,86},{87,89},{46,53},{81,85},{81,97},{22,23},{1,83},{76,85},{71,71},{19,84},{21,53}},
                new int[]{13,97,27,41,45,65,1,81,41,55,61,77,5,56,82,1,1,41,45,62,67,97,96,5,51,77,29,29,85,51,49,69,73,100,65,70,4,79,73,44,99,1,33,9,21,23,77,37,65,44,1,53,61,9,41,69,1,17,77,30,81,51,25,11,62,42,33,59,78,77,87,93,37,77,21,9,61,37,5,46,86,49,79,7,5,77,79,49,16,55,38,70,77,16,13,5,73,29,30,64});
    }



}
